# 4 初始化与清理

## 4.1 构造器

构造器确保每个类被初始化。

构造器名称必须与类名相同，如果没有给类定义构造器，类会有一个无参的默认构造器。

【注意】

*使用「new ClassName()」创建对象时，new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值（并非返回void）。*

## 4.2 this关键字

```java
class Apple { void peel(int i){}}

public class ApplePeel{
  public static void main(String[] args){
    Apple a = new Apple(),
      	  b = new Apple();
    a.peel(1);
    b.peel(2);
  }
}
```

上面代码中，如何区分peel方法是被a还是被b调用？

编译器把「所操作对象的引用」作为第一个参数传递给peel，上面的两个方法的调用就变成了

```java
Apple.peel(a, 1);
Apple.peel(b, 2);
```

---

【通过this在构造器中调用构造器】

- 必须将this的构造器调用置于最起始处，否则编译器会报错。
- 不能同时用this调用两个构造器
- 除构造器之外，编译器禁止在其他任何方法中调用构造器。

## 4.3 方法重载

想用多种方式创造对象，方法重载是必须得，同时，方法重载是构造器所必需的，但同样适用于其他方法。

**每个重载的方法都必须有一个独一无二的参数类型列表。**

参数顺序不同也可以，但最好不要这样做，因为这会使代码难以维护。

---

【涉及基本类型的重载】

- 如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。
- 如果无法找到恰好接受**char**参数的方法，就会把char直接提升为**int**型。

```java
void f1(int x){}
void f1(float x){}
void f2(float y){}

f1(5);//这里调用的是 void f1(int x)方法
f2(5);//这里调用的是 void f2(float y)方法
```

---

【以返回值区分重载方法】

```java
void f(){}
int f(){return 1;}
```

只要编译器能够根据语境明确判断出语义，比如在**int x=f()**中，可以据此区分重载方法。

但对于不关心返回值的调用，比如

```java
f();
```

中，根据返回值来区分重载方法就行不通。

## 4.4 终结处理和垃圾回收

垃圾回收器准备好释放对象占用的存储空间时，将首先调用对象的**finalize()**方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

这就导致finalize不一定会被调用。比

