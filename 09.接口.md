# 9 接口

**接口**和**内部类**提供了一种将接口与实现分离的更加结构化的方法。

通用接口建立起一种基本形式，以此表示所有导出类的共同部分。

## 9.1 抽象类和抽象方法

抽象类是普通类与接口之间的一种中庸之道。



创建抽象类是希望通过这个通用接口操纵一系列类，并不想创建对象，也不希望使用者这样做。通过让抽象类中的所有方法都产生错误可以达到这个目的。但这样会将错误信息延迟到运行时才获得，而且需要进行详尽可靠的测试。为了在编译时捕获这些问题，Java提供了*抽象方法*的机制。



如果一个抽象类包含任何抽象方法都没有实际意义，并且想要阻止产生这个类的任何对象，可以创建一个没有任何抽象方法的抽象类。



抽象类和抽象方法作用：

- 可以使类的抽象性明确起来，并告诉用户和编译器怎么使用它们。
- 是很有用的重构工具，可以很容易地将公共方法沿着继承层次结构向上移动。



## 9.2 接口

一个接口表示：所有实现了该特定接口的类看起来都像这样。

接口用**interface**关键字定义，要让某个类实现该接口，需要使用**implements**关键字。

接口中的方法默认都是**public**的，接口中的域默认都是**public**、**static**和**final**的。



【完全解耦】

只要一个方法操作的是类而非接口，那么就只能使用这个类及其子类来操纵该方法。如果想要将这个方法应用于不在此继承结构中的某个类，就会由于耦合过紧而受到限制。

将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，代码也就更具可复用性。

客户端程序员遵循接口来编写自己的类；但有时无法修改自己的类（类是被调用而非被创建），可以使用*适配器*设计模式，同时也可以使用*代理*。



【多重实现】

导出类只能继承（extends）至多一个父类，可以实现（implements）任意个接口。接口可以继承（extends）任意个接口。

如果导出类继承的父类中有方法和实现的接口中的方法一样，且该方法是**public**的，则无需重写该方法。

```java
interface CanFight {
	void fight();
}
interface CanSwim {
	void swim();
}
interface CanFly {
	void fly();
}
class ActionCharacter {
	public void fight(){}//必须是public的
}

class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly {
	public void swim(){}
	public void fly(){}
}
```



【使用接口的原因】

- 【核心原因】为了向上转型为多个基类型，以及由此带来的灵活性。
- 防止创建该类的对象，确保这仅仅是建立一个接口。



【接口和抽象类的选择】

- 如果要创建不带任何方法定义和成员变量的基类，应该选择接口。
- 如果某事物应该成为一个基类，第一选择应该是使它成为一个接口。



【组合接口时的名字冲突】

覆盖、实现、重载混在一起时，本着一个原则：导出类的接口在导出类中能够找到方法的唯一实现。

【嵌套接口】

嵌套接口可以拥有public、包访问、private可视性。

当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且，private接口不能在定义它的类之外被实现。

【接口工厂】

可以采用工厂方法设计模式创建框架，将代码与接口的实现分离，使得可以透明地将某个实现替换为另一个实现。

---

## 总结

恰当的原则是优先使用类而不是接口，如果接口的必须性变得非常明确，就进行重构。