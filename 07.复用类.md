# 7 复用类

使用别人已经开发并调试好的类，而不破坏现有程序代码。有两种方式：

- **组合**

  在新的类中产生现有类的对象。新的类是由现有类的对象所组成，因此称为组合。

- **继承**

  按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。



## 7.1 组合语法

组合就是将对象的引用置于新类中。

为了避免增加不必要的负担，**对象引用**会被编译器默认初始化为**null**，不会为每个引用创建默认对象。想初始化这些引用，可通过以下4种方式：

1. 在定义对象的地方。

   这意味着通过这种方式初始化的对象引用会在类的构造器被调用之前被初始化。

2. 在类的构造器中。

3. 就在要使用这些对象之前初始化。

   这种方式成为*惰性初始化*。

4. 实例初始化。

   通过**代码块**、**静态代码块**初始化。

## 7.2 继承语法

当使用继承时，导出类会自动得到基类中所有的域和方法。

当创建一个导出类的对象时，该对象包含了一个基类的子对象，这个子对象被包装在导出类对象内部，且与你用基类直接创建的对象是一样的。

对基类子对象的正确初始化，仅有一种方法来保证：在构造器中调用基类构造器来执行初始化。

- 对于无参构造器，编译器会自动在导出类的构造器中插入对基类构造器的调用，即隐藏了导出类构造器第一行的**super()**。
- 对于有参构造器，需要在导出类构造器第一行显式的使用super调用基类的构造器。

## 7.3 代理

Java没有提供对代理的直接支持。

**代理是继承与组合之间的中庸之道**。因为将一个成员对象置于所要构造的类中（就像组合），但与此同时在新类中暴露了该成员对象的所有方法（就像继承）。

《Java编程思想》中提供了太空飞船和太空飞船控制模块的例子，把太空飞船的操控交给交给代理类来代理，而代理类又把操控传递给了底层的控制模块对象。

```java
public class SpaceShipDelegation {
  private SpaceShipDelegation controls = new SpaceShipControls();
  
  public void back(int velocity) {
    controls.back(velocity);
  }
  
  public void forward(int velocity) {
    controls.forward(velocity);
  }
}
```

这样做由于可以选择只提供成员对象的方法的子集，因而**代理可以拥有更多的控制力**（因为继承会把所有的方法继承过去，而有的方法可能并不需要）。

个人的理解：把具体的工作传递给控制模块，类似于MVC（model、view、contrller）模型。

## 7.4 结合使用组合和继承

组合和继承结合使用的情况非常常见，但需要注意两个方面。

1. 确保正确清理

   我们无法知道垃圾回收期何时被调用、是否被调用。如果想要清理一些东西，就必须显式地编写一个特殊方法来做这件事，并确保程序必须调用这个方法。

   比如**try-finally**的**finally**子句中的代码一定会被执行，可以将清理逻辑放在finally中，例如输入输出流的关闭。




*垃圾回收器是否被调用以及回收对象的顺序都无法确定。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要清理，最好是编写自己的清理方法，但不要使用**finalize()**.*



2. 名称屏蔽

如果Java的基类中含有某个已被多次重载的方法，那么在导出类中**重新定义**该方法名称（方法名一样，参数不同）并不会屏蔽其在基类中的任何版本。

如果在导出类中不是重新定义，而是和基类一样的方法及参数，就会屏蔽掉基类对应的方法。



## 7.5 在组合与继承之间选择

“is-a”（是一个）的关系使用继承来表达，“has-a”（有一个）关系则是用组合来表达。

- 组合选择

  **组合技术通常用于在新类中使用现有类的功能而非新类本身的接口这种情形。**

  *（在Door类中嵌入Window类，是为了使用Window类中的功能rollup或者rolldown）*

  即，在新类中（Door）嵌入某个对象（有所需要的功能，window），新类用户（Person）看到的只是为新类所定义的接口（open、close），而非所嵌入的对象的接口（rollup、rolldown）。为此，就需要在新类中嵌入一个现有类的**private**对象。

  ```java
  class Window {
    public void rollup() {}
    public void rolldown() {}
  }

  class Door {
    private Window window = new Window();
    public void open() {}
    public void close() {}
  }

  class Person {
    private Door door = new Door();
  }
  ```
  ​

- 继承选择

  继承是为了使用某个现有类，并开发一个它的特殊版本。这意味着，你在使用一个通用类，并为了某个特殊需要而将其特殊化。




## 7.6 final关键字

final关键字通常表示的含义是「这是无法改变的」。

可能使用到final的三种情况：数据、方法、类。

#### 7.6.1 final数据

final表示的数据恒定不变有两个基本用处：

- 表示一个永不改变的**编译时常量**。

  编译期常量，可以在编译时执行计算式，减轻运行时的负担。

  这类常量必须是**基本数据类型**，必须以关键字final表示，常量定义的时候必须进行初始化。

- 一个运行时被初始化的值，不希望被改变。

  对对象的引用而不是基本类型使用final时，表示**引用恒定不变**。一旦引用被初始化指向一个对象，就无法更改它指向另一个对象，但对象本身却是可以修改的。

一个既是static又是final的域只占用一段不能改变的存储空间。



【空白final】

空白final是指被声明为final但又未给定初值的域。

无论什么情况，编译器都确保空白final在**使用前**必须被初始化。

空白final在关键字final的使用上提供了更大的灵活性：类中的final域可以根据对象而有所不同，却又保持恒定不变的特性。



【final参数】

可以在参数列表中将形参指定为final，表示无法在方法中更改参数。



#### 7.6.2 final方法

使用final方法的目的在于：**明确禁止任何继承类对其覆盖**。



【final与private关键字】

类中所有的private方法都隐式地指定为是final的。给private方法添加final修饰词，不会增加额外意义。

覆盖一个父类的private方法（隐含是final的），编译器也不会给出错误信息。对于父类中的private方法，如果在子类中以相同的名称生成一个public、protected或包访问权限方法的话，此时并没有覆盖该方法，只是生成了一个新方法。

#### 7.6.3 final类

使用final类的目的在于：**禁止该类被继承**。

final类中的所有方法都隐式指定为final的，因为无法覆盖它们。给final类中的方法添加final修饰词，没有意义。



## 7.7 初始化及类的加载

每个类的编译代码都存在于它自己的独立的文件中，该文件只在需要使用程序代码时才会被加载。

***类的代码在初次使用时才加载***。所以，加载发生在创建第一个对象时，或者访问static域或static方法时。

由于构造器也是static方法（尽管static关键字没有显式地写出来），因此更准确地讲：**类是在其任何static成员被访问时加载的**。



【继承与初始化】

类的加载首先会加载其基类，如果其基类还有基类，那么首先会加载第二个基类，如此类推。

根基类中的static初始化会先被执行，然后是下一个导出类的static初始化，如此类推。

类加载完毕，对象就可以被创建了。首先，通过**将对象内存设为二进制零值**的方式，一举将对象中所有的基本类型设为默认值、对象引用设为null。

然后，基类的构造器会被调用，实例变量会按次序进行初始化，然后执行构造器的其余部分；最后，导出类的构造器会被调用，导出类中的实例变量按次序初始化，执行导出类构造器的其余部分，如此类推。



---



## 总结

尽管面向对象对继承极力强调，在设计时，一般优先选择使用组合（或者可能是代理），只在确实必要时才使用继承。